<!DOCTYPE html>
<html lang="en-us">
  <head>
    <base href="https://rolandelving.github.io/krptcedtn/Games/Get%20YOKED/">
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>GET YOKED</title>
    <style>
      html,
      body {
        background: #000;
        width: 100%;
        height: 100%;
        overflow: visible;
        padding: 0;
        margin: 0;
      }

      #gameContainer {
        background: transparent !important;
        position: absolute;
      }

      #gameContainer canvas {
        position: absolute;
      }

      #gameContainer canvas[data-pixel-art="true"] {
        image-rendering: optimizeSpeed;
        image-rendering: -webkit-crisp-edges;
        image-rendering: -moz-crisp-edges;
        image-rendering: -o-crisp-edges;
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        -ms-interpolation-mode: nearest-neighbor;
      }

      #loading-text {
        color: white;
        font-family: sans-serif;
        text-align: center;
        margin-top: 1em;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="unity-canvas" data-pixel-art></canvas>
      <div id="loading-text">LOADING...</div>
    </div>
    <script src="Build/Web.loader.js"></script>
    <script>
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        const meta = document.createElement("meta");
        meta.name = "viewport";
        meta.content =
          "width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes";
        document.head.appendChild(meta);
      }

      const loadingText = document.querySelector("#loading-text");
      let totalBytes = 0;
      let loadedBytes = 0;

      function formatSize(bytes) {
        if (bytes > 1024 * 1024 * 1024)
          return (bytes / (1024 * 1024 * 1024)).toFixed(2) + " GB";
        if (bytes > 1024 * 1024)
          return (bytes / (1024 * 1024)).toFixed(2) + " MB";
        if (bytes > 1024) return (bytes / 1024).toFixed(2) + " KB";
        return bytes + " B";
      }

      async function getSize(url) {
        try {
          const res = await fetch(url, { method: "HEAD" });
          return parseInt(res.headers.get("Content-Length") || "0", 10);
        } catch {
          return 0;
        }
      }

      async function fetchPart(url) {
        console.log("Fetching:", url);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
        }
        
        if (!response.body) {
          const ab = await response.arrayBuffer();
          loadedBytes += ab.byteLength;
          console.log(`Loaded ${url}: ${ab.byteLength} bytes`);
          loadingText.textContent = `LOADING... ${formatSize(
            loadedBytes
          )} / ${formatSize(totalBytes)}`;
          return new Uint8Array(ab);
        }
        
        const reader = response.body.getReader();
        const chunks = [];
        let received = 0;
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          received += value.length;
          loadedBytes += value.length;
          chunks.push(value);
          const percent =
            totalBytes > 0
              ? ((loadedBytes / totalBytes) * 100).toFixed(1)
              : "?";
          loadingText.textContent = `LOADING... ${formatSize(
            loadedBytes
          )} / ${formatSize(totalBytes)} (${percent}%)`;
        }

        console.log(`Loaded ${url}: ${received} bytes`);
        const full = new Uint8Array(received);
        let offset = 0;
        for (let chunk of chunks) {
          full.set(chunk, offset);
          offset += chunk.length;
        }
        return full;
      }

      async function mergeParts(parts, mimeType) {
        const buffers = await Promise.all(parts.map(fetchPart));
        const totalLen = buffers.reduce((s, b) => s + b.length, 0);
        console.log(`Merging ${parts.length} parts, total size: ${totalLen} bytes, MIME: ${mimeType}`);
        
        const concatenated = new Uint8Array(totalLen);
        let off = 0;
        for (let b of buffers) {
          concatenated.set(b, off);
          off += b.length;
        }
        
        const blob = new Blob([concatenated], { type: mimeType || "application/octet-stream" });
        const url = URL.createObjectURL(blob);
        console.log(`Created blob URL: ${url}, size: ${blob.size}, type: ${blob.type}`);
        return url;
      }

      function getParts(file, count) {
        const parts = [];
        for (let i = 1; i <= count; i++) parts.push(file + ".part" + i);
        return parts;
      }

      (async () => {
        try {
          const dataParts = getParts("Build/Web.data", 2);
          const wasmParts = getParts("Build/Web.wasm", 1);
          const allParts = [...dataParts, ...wasmParts, "Build/Web.framework.js"];
          
          console.log("Loading parts:", allParts);
          
          const sizes = await Promise.all(allParts.map(getSize));
          totalBytes = sizes.reduce((a, b) => a + b, 0);
          
          console.log("Total bytes to load:", totalBytes);

          const [dataUrl, wasmUrl, frameworkUrl] = await Promise.all([
            mergeParts(dataParts, "application/octet-stream"),
            mergeParts(wasmParts, "application/wasm"),
            mergeParts(["Build/Web.framework.js"], "application/javascript"),
          ]);

          console.log("All files merged successfully");
          console.log("Data URL:", dataUrl);
          console.log("WASM URL:", wasmUrl);
          console.log("Framework URL:", frameworkUrl);

          const canvas = document.querySelector("#unity-canvas");
          let scaleToFit = true;

          function onResize() {
            const container = canvas.parentElement;
            let w, h;
            if (scaleToFit) {
              w = window.innerWidth;
              h = window.innerHeight;
              const r = 600 / 960;
              if (w * r > window.innerHeight) w = Math.min(w, Math.ceil(h / r));
              h = Math.floor(w * r);
            } else {
              w = 960;
              h = 600;
            }

            container.style.width = canvas.style.width = w + "px";
            container.style.height = canvas.style.height = h + "px";
            container.style.top =
              Math.floor((window.innerHeight - h) / 2) + "px";
            container.style.left =
              Math.floor((window.innerWidth - w) / 2) + "px";
          }
          window.addEventListener("resize", onResize);
          onResize();

          // Wait until Unity loader is available
          loadingText.textContent = "Waiting for Unity loader...";
          await (async function waitForLoader() {
            if (typeof createUnityInstance === "function") return;
            await new Promise((resolve) => {
              const check = setInterval(() => {
                if (typeof createUnityInstance === "function") {
                  clearInterval(check);
                  resolve();
                }
              }, 50);
            });
          })();
          
          console.log("Unity loader ready, creating instance...");
          loadingText.textContent = "Initializing Unity...";
          
          const config = {
            dataUrl: dataUrl,
            frameworkUrl: frameworkUrl,
            codeUrl: wasmUrl,
            streamingAssetsUrl: "StreamingAssets",
            companyName: "Barking Dogs",
            productName: "GET YOKED",
            productVersion: "0.5.0",
          };
          
          console.log("Unity config:", config);
          
          createUnityInstance(canvas, config, (progress) => {
            const percent = Math.round(progress * 100);
            loadingText.textContent = `STARTING GAME... ${percent}%`;
            console.log(`Unity loading progress: ${percent}%`);
          })
            .then((unityInstance) => {
              console.log("Unity instance created successfully!");
              loadingText.remove();
            })
            .catch((message) => {
              console.error("Unity instance creation failed:", message);
              loadingText.textContent = "Failed to start Unity: " + message;
            });
        } catch (err) {
          console.error("Error during initialization:", err);
          loadingText.textContent = "ERROR: " + (err.message || err);
        }
      })();
    </script>
  </body>
</html>
