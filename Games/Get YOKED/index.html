<!DOCTYPE html>
<html lang="en-us">
  <head>
    <base href="https://rolandelving.github.io/krptcedtn/Games/Get%20YOKED/">
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>GET YOKED</title>
    <style>
      html,
      body {
        background: #000;
        width: 100%;
        height: 100%;
        overflow: visible;
        padding: 0;
        margin: 0;
      }

      #gameContainer {
        background: transparent !important;
        position: absolute;
      }

      #gameContainer canvas {
        position: absolute;
      }

      #gameContainer canvas[data-pixel-art="true"] {
        image-rendering: optimizeSpeed;
        image-rendering: -webkit-crisp-edges;
        image-rendering: -moz-crisp-edges;
        image-rendering: -o-crisp-edges;
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        -ms-interpolation-mode: nearest-neighbor;
      }

      #loading-text {
        color: white;
        font-family: sans-serif;
        text-align: center;
        margin-top: 1em;
      }

      #debug-info {
        color: #00ff00;
        font-family: monospace;
        font-size: 12px;
        position: absolute;
        top: 60px;
        left: 10px;
        background: rgba(0,0,0,0.8);
        padding: 10px;
        max-width: 90%;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="unity-canvas" data-pixel-art></canvas>
      <div id="loading-text">LOADING...</div>
      <div id="debug-info"></div>
    </div>
    <script src="Build/Web.loader.js"></script>
    <script>
      const debugInfo = document.querySelector("#debug-info");
      function log(msg) {
        console.log(msg);
        debugInfo.innerHTML += msg + "<br>";
      }

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        const meta = document.createElement("meta");
        meta.name = "viewport";
        meta.content =
          "width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes";
        document.head.appendChild(meta);
      }

      const loadingText = document.querySelector("#loading-text");
      let totalBytes = 0;
      let loadedBytes = 0;

      function formatSize(bytes) {
        if (bytes > 1024 * 1024 * 1024)
          return (bytes / (1024 * 1024 * 1024)).toFixed(2) + " GB";
        if (bytes > 1024 * 1024)
          return (bytes / (1024 * 1024)).toFixed(2) + " MB";
        if (bytes > 1024) return (bytes / 1024).toFixed(2) + " KB";
        return bytes + " B";
      }

      async function getSize(url) {
        try {
          const res = await fetch(url, { method: "HEAD" });
          const size = parseInt(res.headers.get("Content-Length") || "0", 10);
          log(`Size of ${url}: ${formatSize(size)}`);
          return size;
        } catch (e) {
          log(`ERROR getting size of ${url}: ${e.message}`);
          return 0;
        }
      }

      async function fetchPart(url) {
        try {
          log(`Fetching: ${url}`);
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          if (!response.body) {
            const ab = await response.arrayBuffer();
            log(`✓ Loaded ${url}: ${formatSize(ab.byteLength)}`);
            loadedBytes += ab.byteLength;
            loadingText.textContent = `LOADING... ${formatSize(
              loadedBytes
            )} / ${formatSize(totalBytes)}`;
            return new Uint8Array(ab);
          }
          
          const reader = response.body.getReader();
          const chunks = [];
          let received = 0;
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            received += value.length;
            loadedBytes += value.length;
            chunks.push(value);
            const percent =
              totalBytes > 0
                ? ((loadedBytes / totalBytes) * 100).toFixed(1)
                : "?";
            loadingText.textContent = `LOADING... ${formatSize(
              loadedBytes
            )} / ${formatSize(totalBytes)} (${percent}%)`;
          }

          const full = new Uint8Array(received);
          let offset = 0;
          for (let chunk of chunks) {
            full.set(chunk, offset);
            offset += chunk.length;
          }
          log(`✓ Loaded ${url}: ${formatSize(full.length)}`);
          return full;
        } catch (e) {
          log(`✗ ERROR loading ${url}: ${e.message}`);
          throw e;
        }
      }

      async function mergeParts(parts, mimeType) {
        log(`Merging ${parts.length} parts (${mimeType || 'default'})`);
        const buffers = await Promise.all(parts.map(fetchPart));
        const totalLen = buffers.reduce((s, b) => s + b.length, 0);
        log(`Total merged size: ${formatSize(totalLen)}`);
        
        if (totalLen === 0) {
          log(`WARNING: Merged file is 0 bytes!`);
        }
        
        const concatenated = new Uint8Array(totalLen);
        let off = 0;
        for (let b of buffers) {
          concatenated.set(b, off);
          off += b.length;
        }
        const blob = new Blob([concatenated], { type: mimeType || undefined });
        const url = URL.createObjectURL(blob);
        log(`Created blob URL: ${url.substring(0, 50)}...`);
        return url;
      }

      function getParts(file, count) {
        const parts = [];
        for (let i = 1; i <= count; i++) parts.push(file + ".part" + i);
        return parts;
      }

      (async () => {
        try {
          log("=== GET YOKED Loading Debug ===");
          
          const dataParts = ["Build/Web.data"];
          const wasmParts = ["Build/Web.wasm"];
          
          log(`Data parts: ${dataParts.join(', ')}`);
          log(`WASM parts: ${wasmParts.join(', ')}`);
          
          const allParts = [...dataParts, ...wasmParts, "Build/Web.framework.js"];
          
          log("Getting file sizes...");
          const sizes = await Promise.all(allParts.map(getSize));
          totalBytes = sizes.reduce((a, b) => a + b, 0);
          log(`Total download size: ${formatSize(totalBytes)}`);

          log("Starting file downloads...");
          const [dataUrl, wasmUrl, frameworkUrl] = await Promise.all([
            mergeParts(dataParts),
            mergeParts(wasmParts, "application/wasm"),
            mergeParts(["Build/Web.framework.js"], "application/javascript"),
          ]);

          log("All files merged successfully!");
          log("Setting up canvas...");

          const canvas = document.querySelector("#unity-canvas");
          let scaleToFit = true;

          function onResize() {
            const container = canvas.parentElement;
            let w, h;
            if (scaleToFit) {
              w = window.innerWidth;
              h = window.innerHeight;
              const r = 600 / 960;
              if (w * r > window.innerHeight) w = Math.min(w, Math.ceil(h / r));
              h = Math.floor(w * r);
            } else {
              w = 960;
              h = 600;
            }

            container.style.width = canvas.style.width = w + "px";
            container.style.height = canvas.style.height = h + "px";
            container.style.top =
              Math.floor((window.innerHeight - h) / 2) + "px";
            container.style.left =
              Math.floor((window.innerWidth - w) / 2) + "px";
          }
          window.addEventListener("resize", onResize);
          onResize();

          log("Waiting for Unity loader...");
          await (async function waitForLoader() {
            if (typeof createUnityInstance === "function") return;
            await new Promise((resolve) => {
              const check = setInterval(() => {
                if (typeof createUnityInstance === "function") {
                  clearInterval(check);
                  resolve();
                }
              }, 50);
            });
          })();
          
          log("Creating Unity instance...");
          const config = {
            dataUrl: dataUrl,
            frameworkUrl: frameworkUrl,
            codeUrl: wasmUrl,
            streamingAssetsUrl: "StreamingAssets",
            companyName: "Barking Dogs",
            productName: "GET YOKED",
            productVersion: "0.5.0",
          };
          
          createUnityInstance(canvas, config, (progress) => {
            const percent = Math.round(progress * 100);
            loadingText.textContent = `STARTING GAME... ${percent}%`;
          })
            .then((unityInstance) => {
              log("✓ Unity instance created successfully!");
              loadingText.remove();
              setTimeout(() => debugInfo.remove(), 5000);
            })
            .catch((message) => {
              log(`✗ UNITY ERROR: ${message}`);
              loadingText.textContent = "Failed to start Unity: " + message;
              console.error(message);
            });
        } catch (err) {
          log(`✗ FATAL ERROR: ${err.message}`);
          log(`Stack: ${err.stack}`);
          loadingText.textContent = "ERROR: " + (err.message || err);
          console.error(err);
        }
      })();
    </script>
  </body>
</html>
